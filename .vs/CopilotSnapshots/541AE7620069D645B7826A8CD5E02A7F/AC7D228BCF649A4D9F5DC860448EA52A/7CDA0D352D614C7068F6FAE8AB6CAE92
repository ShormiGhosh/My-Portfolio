// Dynamic Portfolio Data Loader
class PortfolioLoader {
    constructor() {
        this.baseUrl = '../api/PortfolioData.ashx';
        this.cache = new Map();
        this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
    }

    async fetchData(type) {
        const cacheKey = type;
        const cached = this.cache.get(cacheKey);
        
        if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
            return cached.data;
        }

        try {
            const response = await fetch(`${this.baseUrl}?type=${type}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Cache the data
            this.cache.set(cacheKey, {
                data: data,
                timestamp: Date.now()
            });
            
            return data;
        } catch (error) {
            console.error(`Error fetching ${type} data:`, error);
            return null;
        }
    }

    async loadSkills() {
        const skills = await this.fetchData('skills');
        if (skills) {
            this.renderSkills(skills);
        }
    }

    async loadProjects() {
        const projects = await this.fetchData('projects');
        if (projects) {
            this.renderProjects(projects);
        }
    }

    async loadAchievements() {
        const achievements = await this.fetchData('achievements');
        if (achievements) {
            this.renderAchievements(achievements);
        }
    }

    async loadWorkExperience() {
        const workExperience = await this.fetchData('workexperience');
        if (workExperience) {
            this.renderWorkExperience(workExperience);
        }
    }

    async loadProfile() {
        const profile = await this.fetchData('profile');
        if (profile) {
            this.renderProfile(profile);
        }
    }

    async loadAll() {
        try {
            // Load all data in parallel for better performance
            const [skills, projects, achievements, workExperience, profile] = await Promise.all([
                this.fetchData('skills'),
                this.fetchData('projects'),
                this.fetchData('achievements'),
                this.fetchData('workexperience'),
                this.fetchData('profile')
            ]);

            // Render all data
            if (skills) this.renderSkills(skills);
            if (projects) this.renderProjects(projects);
            if (achievements) this.renderAchievements(achievements);
            if (workExperience) this.renderWorkExperience(workExperience);
            if (profile) this.renderProfile(profile);

            console.log('All portfolio data loaded successfully');
        } catch (error) {
            console.error('Error loading portfolio data:', error);
        }
    }

    renderSkills(skillsData) {
        // Map admin categories to frontend categories
        const categoryMap = {
            'Programming Languages': '.programing-lang ul',
            'Frameworks & Libraries': '.frame-lib ul',
            'Tools & Technologies': '.tool-technology ul',
            'Soft Skills': '.soft ul'
        };

        Object.keys(skillsData).forEach(category => {
            const selector = categoryMap[category];
            if (!selector) return;

            const container = document.querySelector(selector);
            if (!container) return;

            // Clear existing dynamic content but keep static items
            const existingItems = container.querySelectorAll('.dynamic-skill');
            existingItems.forEach(item => item.remove());

            // Add new skills
            skillsData[category].forEach(skill => {
                const li = document.createElement('li');
                li.className = 'dynamic-skill';
                li.textContent = skill.name;
                container.appendChild(li);
            });
        });

        console.log('Skills rendered successfully');
    }

    renderProjects(projects) {
        const projectList = document.querySelector('.project-list');
        if (!projectList) return;

        // Clear existing dynamic projects
        const existingProjects = projectList.querySelectorAll('.dynamic-project');
        existingProjects.forEach(project => project.remove());

        // Add new projects
        projects.forEach(project => {
            const projectItem = this.createProjectElement(project);
            projectList.appendChild(projectItem);
        });

        // Reinitialize mobile interactions for new projects
        setTimeout(() => {
            initializeMobileProjectInteractions();
        }, 100);

        console.log('Projects rendered successfully');
    }

    createProjectElement(project) {
        const projectDiv = document.createElement('div');
        projectDiv.className = 'project-item dynamic-project';
        
        // Handle image path - check if it needs ../ prefix
        let imageSrc = project.imagePath;
        if (imageSrc && !imageSrc.startsWith('http') && !imageSrc.startsWith('../')) {
            imageSrc = `../${imageSrc}`;
        }

        projectDiv.innerHTML = `
            <img src="${imageSrc}" alt="${project.title} project">
            <div class="layer">
                <h3>${project.title}</h3>
                <p>${project.description}</p>
                ${project.githubUrl ? `<a href="${project.githubUrl}" target="_blank"><i class="fab fa-github"></i></a>` : ''}
            </div>
        `;

        return projectDiv;
    }

    renderAchievements(achievements) {
        const achievementsContainer = document.querySelector('.achievements-container');
        if (!achievementsContainer) return;

        // Clear existing dynamic achievements
        const existingAchievements = achievementsContainer.querySelectorAll('.dynamic-achievement');
        existingAchievements.forEach(achievement => achievement.remove());

        // Add new achievements
        achievements.forEach(achievement => {
            const achievementItem = this.createAchievementElement(achievement);
            achievementsContainer.appendChild(achievementItem);
        });

        console.log('Achievements rendered successfully');
    }

    createAchievementElement(achievement) {
        const achievementDiv = document.createElement('div');
        achievementDiv.className = 'achievement-item dynamic-achievement';
        
        // Handle image path
        let imageSrc = achievement.imagePath;
        if (imageSrc && !imageSrc.startsWith('http') && !imageSrc.startsWith('../')) {
            imageSrc = `../${imageSrc}`;
        }

        achievementDiv.innerHTML = `
            <div class="achievement-image">
                <img src="${imageSrc}" alt="${achievement.title}">
            </div>
            <div class="achievement-content">
                <h3 class="achievement-title">${achievement.title}</h3>
                <p class="achievement-description">${achievement.description}</p>
            </div>
        `;

        return achievementDiv;
    }

    renderWorkExperience(workExperiences) {
        const experienceList = document.getElementById('experienceList');
        const noExperience = document.getElementById('noExperience');
        
        if (!experienceList || !noExperience) return;

        if (workExperiences.length === 0) {
            // Show no experience message
            experienceList.style.display = 'none';
            noExperience.style.display = 'block';
        } else {
            // Show experience list and hide no experience message
            noExperience.style.display = 'none';
            experienceList.style.display = 'block';
            
            // Clear existing content
            experienceList.innerHTML = '';
            
            // Add each experience
            workExperiences.forEach(exp => {
                const experienceItem = this.createWorkExperienceElement(exp);
                experienceList.appendChild(experienceItem);
            });
        }

        console.log('Work experience rendered successfully');
    }

    createWorkExperienceElement(experience) {
        const item = document.createElement('div');
        item.className = 'experience-item';
        
        item.innerHTML = `
            <div class="company">${experience.companyName}</div>
            <div class="position">${experience.jobTitle}</div>
            <div class="duration">${experience.duration}</div>
        `;
        
        return item;
    }

    renderProfile(profile) {
        // Update profile image if provided
        if (profile.profileImagePath) {
            const profileImg = document.querySelector('.profile-img');
            if (profileImg) {
                let imageSrc = profile.profileImagePath;
                if (!imageSrc.startsWith('http') && !imageSrc.startsWith('../')) {
                    imageSrc = `../${imageSrc}`;
                }
                profileImg.src = imageSrc;
            }

            // Update about section profile image
            const aboutImg = document.querySelector('.about-col1 img');
            if (aboutImg) {
                let imageSrc = profile.profileImagePath;
                if (!imageSrc.startsWith('http') && !imageSrc.startsWith('../')) {
                    imageSrc = `../${imageSrc}`;
                }
                aboutImg.src = imageSrc;
            }
        }

        // Update CV download link if provided
        if (profile.cvPath) {
            const cvLink = document.querySelector('.down-cv-btn');
            if (cvLink) {
                let cvSrc = profile.cvPath;
                if (!cvSrc.startsWith('http') && !cvSrc.startsWith('../')) {
                    cvSrc = `../${cvSrc}`;
                }
                cvLink.href = cvSrc;
            }
        }

        console.log('Profile rendered successfully');
    }

    // Method to refresh data (can be called when admin updates content)
    async refresh() {
        // Clear cache
        this.cache.clear();
        
        // Reload all data
        await this.loadAll();
        
        console.log('Portfolio data refreshed');
    }

    // Method to periodically refresh data
    startAutoRefresh(intervalMinutes = 10) {
        setInterval(() => {
            this.checkForUpdates();
        }, intervalMinutes * 60 * 1000);
        
        // Also check for updates more frequently (every 30 seconds)
        setInterval(() => {
            this.checkForUpdates();
        }, 30000);
    }

    // Check if admin has updated data
    async checkForUpdates() {
        try {
            const response = await fetch('../api/RefreshNotifier.ashx?action=check');
            if (response.ok) {
                const result = await response.json();
                const lastUpdate = new Date(result.lastUpdate);
                const lastChecked = this.cache.get('lastChecked') || new Date(0);
                
                if (lastUpdate > lastChecked) {
                    console.log('New data detected, refreshing portfolio...');
                    await this.refresh();
                    this.cache.set('lastChecked', new Date());
                }
            }
        } catch (error) {
            console.log('Could not check for updates:', error.message);
        }
    }
}

// Create global instance
window.portfolioLoader = new PortfolioLoader();

// Auto-load data when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Small delay to ensure other scripts are loaded
    setTimeout(() => {
        window.portfolioLoader.loadAll();
        
        // Start auto-refresh every 10 minutes
        window.portfolioLoader.startAutoRefresh(10);
    }, 1000);
});

// Export for ES6 modules if needed
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PortfolioLoader;
}